
    def get_constraints_from_attribute_declarator(self, 
            typet, 
            ctx: Java9Parser.VariableDeclaratorContext):
        i = ctx.variableInitializer()
        if not i:
            return
        # Get the compile time type of the left hand side from the type
        lhs_type = self.get_type_from_variable_declarator_id(typet,
                i.variableDeclaratorId())
        print(lhs_type)
        # Get the compile time type of the right hand side 
        # TODO: Handle array initializer
        i = i.expression()
        rhs_type = self.get_type_of_expression_in_attribute_declarator(typet, i)
        self._worklist.append(SubtypeConstraint(rhs_type, lhs_type))

    def get_type_from_variable_declarator_id(self, typet, ctx):
        identifier = ctx.identifier().getText()
        #TODO: handle dims
        if identifier in typet._attributes:
            return typet._attributes[identifier]
        # variable is in one of the supertypes
        scls = typet._superclass
        if not scls:
            raise Exception(f'Attribute {identifier} not found')
        if scls._identifier in self._declared_types:
            return self.get_type_from_variable_declarator_id(scls, ctx)
        t_dcl = self._missing_types[scls._identifier]
        if identifier not in t_dcl._attributes:
            t_dcl.add_attribute(Attribute(identifier, InferenceVariable(),
                False, False))
        return t_dcl._attributes[identifier]
        
    def get_type_of_expression_in_attribute_declarator(self, typet, ctx):
        # TODO: Handle lambda expression
        i = ctx.assignmentExpression()
        return self.handle_assignment_expression_in_attribute_declarator(typet, i)

    def handle_assignment_expression_in_attribute_declarator(self, typet, ctx):
        cond_e = ctx.conditionalExpression()
        assignment = ctx.assignment()
        if cond_e:
            return self.handle_conditional_expression_in_attribute_declarator(typet, cond_e)
        return self.handle_assignment_in_attribute_declarator(typet, assignment)

    def handle_assignment_in_attribute_declarator(self, typet, ctx):
        lhs = ctx.leftHandSide()
        # Handle fieldAccess
        fa = lhs.fieldAccess()
        if fa:
            lhs_type = self.get_type_from_field_access_in_attribute_declarator(typet, fa)
        # handle expressionName
        en = lhs.expressionName()
        if en:
            lhs_type = self.get_type_from_expression_name_in_attribute_declarator(typet, en)
        # TODO: handle array access.
        pass

    def get_type_from_field_access_in_attribute_declarator(self, typet, ctx):
        '''
        fieldAccess
	    :	primary '.' identifier
	    |	'super' '.' identifier
	    |	typeName '.' 'super' '.' identifier
	    ;
        '''
        field_id = ctx.identifier().getText()
        typename = ctx.typeName()
        if typename:
            #TODO handle nested typename
            supertype_id = typename.identifier().getText()
            if supertype_id in self._declared_types:
                typet = self._declared_types[supertype_id]
            elif supertype_id not in self._missing_types:
                typet = JavaClassDeclaration(supertype_id)
                self._missing_types[supertype_id] = typet
        else:
            primary = ctx.primary()
            if not primary:
                # means must be super.identifier
                supertype_id = typet._superclass._identifier
                if supertype_id in self._declared_types:
                    typet = self._declared_types[supertype_id]
                elif supertype_id not in self._missing_types:
                    typet = JavaClassDeclaration(supertype_id)
                    self._missing_types[supertype_id] = typet
            # primary
            else:
                typet = self.get_type_from_primary_in_attribute_declarator(typet, primary)
        return self.get_attribute_from_class_declaration(typet, field_id) 

    def get_attribute_from_class_declaration(self, typet, identifier):
        if identifier in typet._attributes:
            return typet._attributes[identifier]
        # variable is in one of the supertypes
        scls = typet._superclass
        if not scls:
            raise Exception(f'Attribute {identifier} not found')
        if scls._identifier in self._declared_types:
            return self.get_attribute_from_class_declaration(scls, identifier)
        t_dcl = self._missing_types[scls._identifier]
        if identifier not in t_dcl._attributes:
            t_dcl.add_attribute(Attribute(identifier, InferenceVariable(),
                False, False))
        return t_dcl._attributes[identifier]


    def get_type_from_primary_in_attribute_declarator(self, typet, ctx: Java9Parser.PrimaryContext):
        pnnalfnop = ctx.primaryNoNewArray_lfno_primary()
        pnnalfnop_type = self.get_type_from_primaryNoNewArray_lfno_primary(typet,
                pnnalfnop)

        ace = ctx.arrayCreationExpression()
        pnnalfp = ctx.primaryNoNewArray_lf_primary()
        #TODO Handle Array Creation Expression

    def get_type_from_primaryNoNewArray_lfno_primary(self, typet,
            ctx:Java9Parser.PrimaryNoNewArray_lfno_primaryContext):
        '''
        primaryNoNewArray_lfno_primary
	:	literal
	|	typeName ('[' ']')* '.' 'class'
	|	unannPrimitiveType ('[' ']')* '.' 'class'
	|	'void' '.' 'class'
	|	'this'
	|	typeName '.' 'this'
	|	'(' expression ')'
	|	classInstanceCreationExpression_lfno_primary
	|	fieldAccess_lfno_primary
	|	arrayAccess_lfno_primary
	|	methodInvocation_lfno_primary
	|	methodReference_lfno_primary
	;
        '''
        if ctx.literal():
            return self.get_type_of_literal(ctx.literal())
        if ctx.typeName():
            ctt = CompileTimeType(ctx.typeName().identifier().getText())
            if '.this' in ctx.getText():
                return ctt
            cap = Capture()
            cap.set_base = ctt
            cap.set_type = Capture.EXACT
            return CompileTimeType('Class', [cap])
        if ctx.expression():
            return self.get_type_of_expression_in_attribute_declarator(typet, ctx.expression())
        if ctx.classInstanceCreationExpression_lfno_primary():
            return self.get_type_of_class_instance_creation_expression_lf(typet,
                    ctx.classInstanceCreationExpression_lfno_primary())
        #
        return 1

    def get_type_of_class_instance_creation_expression_lf(self, typet, ctx):
        # TODO: Handle expressionName
        ctt = CompileTimeType(ctx.identifier().getText())
        tad = ctx.typeArgumentsOrDiamond()
        if tad.typeArguments():
            tad._captures.extend(self.handle_type_arguments(tad.typeArguments()))
        else:
            ctt._is_diamond = True
        # TODO: HANDLE CONSTRUCTOR TYPE INFERENCES
        return ctt


    def get_type_of_literal(self, ctx: Java9Parser.LiteralContext):
        if ctx.IntegerLiteral():
            return CompileTimeType('int')
        if ctx.FloatingPointLiteral():
            return CompileTimeType('float')
        if ctx.BooleanLiteral():
            return CompileTimeType('boolean')
        if ctx.CharacterLiteral():
            return CompileTimeType('char')
        if ctx.StringLiteral():
            return CompileTimeType('String')
        return CompileTimeType('null')

